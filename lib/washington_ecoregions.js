// Generated by CoffeeScript 1.10.0
(function() {
  var currentTreeId, desertLabel, disclaimer, drawTreeMenu, getClassNameEco, getClassNameTree, getColor, getSubClassNameEco, getTreeGrid, height, hideLabels, hideTreeMenuText, initMap, lightenColor, loadJson, makeProjection, mapDescription, mapTitle, marineLabel, mountainLabel, onClickEco, onClickTree, overflow_limit, path, portrait, positionText, processTree, projection, quote, region_trees, removeImages, resize, selected, selectedTree, setTitleAndDescription, setTreeMenuText, shadeColor2, showDisclaimer, showImage, showLabels, showQuote, sizes, smallmode, splitText, svg, tinymode, treeMenuLat, treeMenuLon, treeMenuOverflowText, treeMenuText, tree_regions, trees, width;

  selected = selectedTree = currentTreeId = null;

  region_trees = {};

  tree_regions = {};

  trees = {};

  sizes = {
    x: 90,
    y: 162,
    padding: 15
  };

  overflow_limit = 25;

  width = height = 0;

  mapTitle = mapDescription = treeMenuText = treeMenuOverflowText = marineLabel = mountainLabel = desertLabel = null;

  disclaimer = [];

  quote = [];

  treeMenuLat = treeMenuLon = 0;

  smallmode = tinymode = false;

  portrait = false;

  svg = d3.select('#map').append('svg').attr('id', 'svg');

  projection = path = null;

  makeProjection = function() {
    var scaling;
    if (portrait) {
      scaling = 7;
    } else {
      scaling = 5;
    }
    projection = d3.geo.mercator().scale(width * scaling).center([-125, 49.55]).translate([0, 0]);
    return path = d3.geo.path().projection(projection);
  };

  $("#disclaimer").click(function() {
    return showDisclaimer();
  });

  initMap = function(error, ecotopo) {
    var data, i, k, l, len, len1, len2, line, m, ref, ref1, ref2;
    if (error) {
      return console.log(error);
    }
    data = topojson.feature(ecotopo, ecotopo.objects.ecoregions);
    svg.selectAll('.subunit').data(data.features).enter().append('path').attr('class', getClassNameEco).on('click', onClickEco).attr('d', path).style('fill', getColor);
    mapTitle = svg.append('text').attr('class', 'mapname').text('Evergreens of Washington');
    mapDescription = svg.append('text').attr('class', 'selected detail').text('Select an ecoregion to see the list of evergreen trees native to it.');
    treeMenuText = svg.append('text').attr('class', 'selected title').text('');
    treeMenuOverflowText = svg.append('text').attr('class', 'selected title').text('');
    ref = ["Tree ranges are based on the data ", "available and not guaranteed to be", "accurate."];
    for (i = k = 0, len = ref.length; k < len; i = ++k) {
      line = ref[i];
      disclaimer.push(svg.append("text").attr("class", "disclaimer").style('opacity', 0).text(line));
    }
    ref1 = ["A tree is beautiful, but whatâ€™s more, it has a right ", "to life; like water, the sun and the stars, it is ", "essential. Life on earth is inconceivable without trees.", " - Anton Chekov"];
    for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
      line = ref1[i];
      quote.push(svg.append("text").attr("class", "quote").style('opacity', 0).text(line));
    }
    mountainLabel = svg.append("text").attr("class", "label").text("Northwestern Forested Mountains");
    desertLabel = svg.append("text").attr("class", "label").text("North American Deserts");
    marineLabel = svg.append("text").attr("class", "label").text("Marine West Coast Forest");
    ref2 = data.features;
    for (m = 0, len2 = ref2.length; m < len2; m++) {
      path = ref2[m];
      region_trees[path.id] = [];
    }
    loadJson('trees.wa.json');
    resize();
    positionText();
    return showQuote();
  };

  positionText = function() {
    var coords, coordsOverflow, coordsParagraph, coordsText, diffHeader, diffParagraph, i, k, l, len, len1, line, titleLat, titleLon;
    if (portrait) {
      titleLat = 49.3;
      titleLon = -124.6;
    } else {
      titleLat = 49.3;
      titleLon = -123.2;
    }
    coords = projection([titleLon, titleLat]);
    mapTitle.attr('x', coords[0]).attr('y', coords[1]).style('font-size', tinymode ? '23px' : '50px');
    coords = projection([titleLon + 0.05, titleLat - 0.18]);
    mapDescription.attr('x', coords[0]).attr('y', coords[1]).style('font-size', tinymode ? '12px' : '14px');
    if (portrait) {
      treeMenuLat = 45.33;
      treeMenuLon = -124.7;
    } else {
      treeMenuLat = 49;
      treeMenuLon = -116.9;
    }
    diffHeader = projection.invert([0, 0])[1] - projection.invert([0, 19])[1];
    diffParagraph = 16;
    coordsText = projection([treeMenuLon, treeMenuLat - diffHeader]);
    coordsOverflow = projection([treeMenuLon, treeMenuLat - diffHeader * 2]);
    coordsParagraph = projection([treeMenuLon, treeMenuLat - 0.15]);
    treeMenuText.attr('x', coordsText[0]).attr('y', coordsText[1]);
    treeMenuOverflowText.attr('x', coordsOverflow[0]).attr('y', coordsOverflow[1]);
    for (i = k = 0, len = disclaimer.length; k < len; i = ++k) {
      line = disclaimer[i];
      line.attr("x", coordsParagraph[0]).attr("y", coordsParagraph[1] + (i + 2) * diffParagraph);
    }
    for (i = l = 0, len1 = quote.length; l < len1; i = ++l) {
      line = quote[i];
      line.attr("x", coordsParagraph[0]).attr("y", coordsParagraph[1] + i * diffParagraph);
    }
    coords = projection([-121.5, 48.75]);
    mountainLabel.attr("x", coords[0]).attr("y", coords[1]);
    coords = projection([-120.5, 46.8]);
    desertLabel.attr("x", coords[0]).attr("y", coords[1]);
    coords = projection([-124.5, 47.9]);
    marineLabel.attr("x", coords[0]).attr("y", coords[1]);
    if (smallmode) {
      marineLabel.text("");
      desertLabel.text("");
      mountainLabel.text("");
    } else {
      mountainLabel.text("Northwestern Forested Mountains");
      desertLabel.text("North American Deserts");
      marineLabel.text("Marine West Coast Forest");
    }
    d3.select('#info').style('visibility', 'visible');
    if (tinymode) {
      return d3.select('#info').style('padding', '4px').style('font-size', '9px');
    }
  };

  processTree = function(tree) {
    var className, k, len, ref, region;
    console.log("~~~" + tree["common"] + "~~~");
    ref = tree["regions"];
    for (k = 0, len = ref.length; k < len; k++) {
      region = ref[k];
      region_trees[region].push(tree["common"]);
    }
    className = getClassNameTree(tree["common"]);
    tree_regions[className] = tree["regions"];
    return trees[className] = tree;
  };

  loadJson = function(fname) {
    console.log("loading", fname);
    return fetch(fname, {
      method: 'get'
    }).then(function(response) {
      return response.json();
    }).then(function(json) {
      var k, len, ref, results, tree;
      ref = json["evergreen"];
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        tree = ref[k];
        results.push(processTree(tree));
      }
      return results;
    })["catch"](function(e) {
      return console.log("FLAGRANT ERROR:", e);
    });
  };

  onClickTree = function(d, i) {
    var description, k, l, len, len1, name, region, region_list;
    if (selectedTree) {
      d3.select(selectedTree).style('opacity', '1');
      region_list = tree_regions[selectedTree.id];
      for (k = 0, len = region_list.length; k < len; k++) {
        region = region_list[k];
        d3.selectAll('.' + getSubClassNameEco(region)).style('opacity', '1').style('color', getColor);
      }
    }
    selectedTree = this;
    d3.selectAll('image').style('opacity', '0.5');
    d3.select(selectedTree).style('opacity', '1');
    hideLabels();
    region_list = tree_regions[selectedTree.id];
    d3.selectAll(".subunit").style('opacity', '0.25');
    for (l = 0, len1 = region_list.length; l < len1; l++) {
      region = region_list[l];
      d3.selectAll('.' + getSubClassNameEco(region)).style('opacity', '1');
    }
    name = selectedTree.id.split('_').join(' ');
    name = name.charAt(0).toUpperCase() + name.slice(1);
    description = trees[selectedTree.id]['latin'];
    return setTitleAndDescription(name, description);
  };

  onClickEco = function(d) {
    var k, len, region, region_list;
    hideTreeMenuText();
    if (selected) {
      selected.style('stroke', 'none');
      if (selectedTree) {
        region_list = tree_regions[selectedTree.id];
        for (k = 0, len = region_list.length; k < len; k++) {
          region = region_list[k];
          d3.selectAll('.subunit').style('opacity', '1');
        }
        selectedTree = null;
        setTitleAndDescription('Evergreens of Washington', '');
        showLabels();
      }
    } else {
      setTitleAndDescription('Evergreens of Washington', 'Select a tree to see which ecoregions it grows in.');
    }
    selected = d3.select(this);
    selected.style('stroke', 'red');
    return drawTreeMenu(d.id);
  };

  drawTreeMenu = function(treeId, selected) {
    var bottom, grid, i, k, len, stateBottom, tree, tree_list;
    currentTreeId = treeId;
    removeImages();
    if (!treeId) {
      return;
    }
    tree_list = region_trees[treeId];
    setTreeMenuText(treeId.split(' ').slice(2).join(' '));
    grid = getTreeGrid(tree_list.length);
    for (i = k = 0, len = tree_list.length; k < len; i = ++k) {
      tree = tree_list[i];
      showImage(tree, i, grid);
    }
    bottom = grid.startCoords[1] + grid.rows * grid.stride.y + 15;
    stateBottom = projection([-122, 45.5])[1];
    bottom = Math.ceil(Math.max(bottom, stateBottom));
    return svg.style('width', width + 'px').style('height', bottom + 'px');
  };

  getTreeGrid = function(n_trees) {
    var columns, diff, rows, startCoords, stride;
    diff = projection.invert([0, 0])[1] - projection.invert([0, 44])[1];
    startCoords = projection([treeMenuLon, treeMenuLat - diff]);
    stride = {
      x: sizes.x + sizes.padding,
      y: sizes.y + sizes.padding
    };
    if (portrait) {
      columns = Math.floor(width / stride.x);
    } else {
      columns = 3;
    }
    rows = Math.ceil(n_trees / columns);
    return {
      columns: columns,
      rows: rows,
      stride: stride,
      startCoords: startCoords
    };
  };

  showImage = function(name, i, grid) {
    var fname, id, x, y;
    id = getClassNameTree(name);
    fname = id + ".jpg";
    x = grid.startCoords[0] + (i % grid.columns) * grid.stride.x;
    y = grid.startCoords[1] + (Math.floor(i / grid.columns)) * grid.stride.y;
    return svg.append("svg:image").attr("xlink:href", "images/" + fname).attr("x", x).attr("y", y).attr("width", sizes.x).attr("height", sizes.y).attr("id", id).on('click', onClickTree);
  };

  removeImages = function() {
    return svg.selectAll("image").remove();
  };

  getClassNameEco = function(d) {
    var l1, subclass;
    subclass = getSubClassNameEco(d.id);
    l1 = d.properties.L1.split(' ').slice(2);
    return 'subunit ' + l1.join('_') + ' ' + subclass;
  };

  lightenColor = function(d, i) {
    var color;
    color = getColor(d, i);
    return shadeColor2(color, 0.05);
  };

  getColor = function(d, i) {
    var base, color, index, j, k, l1, l1_dict, l2, l4, l4_dict, len, letter, percent, ref;
    l1_dict = {
      '10': '#aa9900',
      '6': '#337711',
      '7': '#118855'
    };
    j = 0;
    l4_dict = {};
    ref = 'abcdefghijklmnopqrstuvwxyz';
    for (index = k = 0, len = ref.length; k < len; index = ++k) {
      letter = ref[index];
      l4_dict[letter] = index;
    }
    l1 = d.properties.L1.split(' ')[0];
    l4 = d.id.split(' ')[0];
    l2 = parseInt(l4.slice(0, -1));
    letter = l4.slice(-1);
    base = l1_dict[l1];
    percent = (l4_dict[letter] % 5) / 10;
    color = shadeColor2(base, percent);
    return color;
  };

  shadeColor2 = function(color, percent) {
    var B, G, R, f, p, t;
    f = parseInt(color.slice(1), 16);
    t = percent < 0 ? 0 : 255;
    p = percent < 0 ? percent * -1 : percent;
    R = f >> 16;
    G = f >> 8 & 0x00FF;
    B = f & 0x0000FF;
    return "#" + (0x1000000 + (Math.round((t - R) * p) + R) * 0x10000 + (Math.round((t - G) * p) + G) * 0x100 + (Math.round((t - B) * p) + B)).toString(16).slice(1);
  };

  getSubClassNameEco = function(s) {
    var l4;
    l4 = s.split(' ').slice(2);
    return l4.join('_').replace('/', '_');
  };

  getClassNameTree = function(s) {
    return s.toLowerCase().replace(/ /g, '_');
  };

  splitText = function(text) {
    var result, split;
    split = text.split(' ');
    result = '';
    while (result.length < overflow_limit && split) {
      if (result.length + split[0].length <= overflow_limit) {
        result += split.shift() + ' ';
      } else {
        break;
      }
    }
    return [result, split.join(' ')];
  };

  setTitleAndDescription = function(title, description) {
    if (mapTitle.text() !== title) {
      mapTitle.transition().duration(50).style('opacity', 0).transition().duration(250).style('opacity', 1).text(title);
    }
    if (mapDescription.text() !== description) {
      return mapDescription.transition().duration(50).style('opacity', 0).transition().duration(250).style('opacity', 1).text(description);
    }
  };

  setTreeMenuText = function(text, detailText) {
    var list, overflow, split;
    overflow = '';
    if (text.length > overflow_limit) {
      list = splitText(text);
      text = list[0];
      overflow = list[1];
    }
    treeMenuText.transition().duration(50).style('opacity', 0).transition().duration(250).style('opacity', 1).text(text);
    treeMenuOverflowText.transition().duration(50).style('opacity', 0).transition().duration(250).style('opacity', 1).text(overflow);
    if (detailText) {
      return split = splitText(detailText);
    }
  };

  hideLabels = function() {
    if (!marineLabel || !desertLabel || !mountainLabel) {
      console.log("null");
      return;
    }
    mountainLabel.transition().duration(50).style('opacity', 0);
    desertLabel.transition().duration(50).style('opacity', 0);
    return marineLabel.transition().duration(50).style('opacity', 0);
  };

  showLabels = function() {
    mountainLabel.transition().duration(50).style('opacity', 1);
    desertLabel.transition().duration(50).style('opacity', 1);
    return marineLabel.transition().duration(50).style('opacity', 1);
  };

  showQuote = function() {
    var k, len, line, results;
    removeImages();
    setTreeMenuText("");
    results = [];
    for (k = 0, len = quote.length; k < len; k++) {
      line = quote[k];
      results.push(line.transition().duration(50).style('opacity', 1));
    }
    return results;
  };

  showDisclaimer = function() {
    var k, len, line, results;
    removeImages();
    hideTreeMenuText();
    setTreeMenuText("Disclaimer");
    results = [];
    for (k = 0, len = disclaimer.length; k < len; k++) {
      line = disclaimer[k];
      results.push(line.transition().duration(50).style('opacity', 1));
    }
    return results;
  };

  hideTreeMenuText = function() {
    var k, l, len, len1, line, results;
    for (k = 0, len = disclaimer.length; k < len; k++) {
      line = disclaimer[k];
      line.transition().duration(50).style('opacity', 0);
    }
    results = [];
    for (l = 0, len1 = quote.length; l < len1; l++) {
      line = quote[l];
      results.push(line.transition().duration(50).style('opacity', 0));
    }
    return results;
  };

  resize = function() {
    var bodyHeight, mapRatio, margin, stateBottom;
    smallmode = tinymode = false;
    portrait = false;
    margin = {
      top: 10,
      left: 10,
      bottom: 10,
      right: 10
    };
    width = $(window).width();
    width = width - margin.left - margin.right;
    bodyHeight = $(window).height();
    mapRatio = .55;
    height = width * mapRatio;
    if (width < 1500) {
      smallmode = true;
    }
    if (width < 800) {
      tinymode = true;
    }
    if (bodyHeight > width || tinymode) {
      mapRatio = width / bodyHeight;
      portrait = true;
      height = $(window).height();
    }
    if (portrait) {
      overflow_limit = 32;
    } else {
      overflow_limit = 25;
    }
    makeProjection();
    stateBottom = projection([-122, 45.5])[1];
    height = Math.max(height, stateBottom);
    svg.style('width', width + 'px').style('height', height + 'px');
    console.log("resized to", width, height);
    svg.selectAll('.subunit').attr('d', path);
    positionText();
    return drawTreeMenu(currentTreeId);
  };

  d3.json("washington.topojson", initMap);

  d3.select(window).on('resize', resize);

}).call(this);
